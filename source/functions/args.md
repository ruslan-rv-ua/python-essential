# Параметри і аргументи функцій

Викликаючи функцію, ми можемо передавати їй наступні типи аргументів:

* позиційні аргументи (positional arguments)
* іменовані аргументи (keyword arguments)
* опціональні аргументи (default arguments)
* аргумети довільної довжини (variable-length argumens)


## Позиційні аргументи

Коли викликаємо функцію фактичні параметри заміщують формальні у тому порядку, у якому їх вказано.

	:::python
	>>> def product_info(name, color, price):
	...     print('Product:', name)
	...     print('Color:', color)
	...     print('Price:', price)
	...
	>>> product_info('Pen', 'blue', 2)
	Product: Pen
	Color: blue
	Price: 2
	>>>
	>>> product_info(2, 'Pen', 'blue')
	Product: 2
	Color: Pen
	Price: blue
	>>>

## Іменовані аргументи

Ми маємо можливість змінити порядок слідування аргументів. Для цього при вказанні значень аргументів необхідно вказувати також ї імена відповідних параметрів функції у вигляді:

`параметр=значення`

Подивимось як можна викликати попередньо написану функцію:

	:::python
	>>> product_info(price=2, name='Pen', color='blue')
	Product: Pen
	Color: blue
	Price: 2
	>>>

При викликах функцій можна одночасно використовувати як позиційні, так і іменовані аргументи. Спочатку треба вказати певну кількість позиційних аргументів, які будуть заміщати відповідні їм по порядку параметри, а потім для усіх аргументів, що залишились, вказуємо іменовані аргументи у довільному порядку:

	:::python
	>>> product_info('Pen', price=2, color='blue')
	Product: Pen
	Color: blue
	Price: 2
	>>>

У прикладі вище перший аргумент буде відповідати параметру функції `name`, інші ж аргументи ми вказали з іменами параметрів.

Спроба вказати позиційний аргумент після іменованих призведе до відповідної помилки:

	:::python
	>>> product_info(price=2, color='blue', 'Pen')
	  File "<stdin>", line 1
	SyntaxError: positional argument follows keyword argument
	>>>
	
## Опціональні параметри

Деякі параметри функції можна зробити необов'язковими. 
Для цього для них при визначенні функції треба вказати значення за замовчуванням. 
Це значення буде присвоєно параметру якщо ми викликаючи функцію не вкажемо відповідний аргумент:

	:::python
	>>> def product_info(name, color='blue', price=7):
	...     print('Product:', name)
	...     print('Color:', color)
	...     print('Price:', price)
	...
	>>> product_info('Pen')
	Product: Pen
	Color: blue
	Price: 7
	>>> product_info('Pen', 'red')
	Product: Pen
	Color: red
	Price: 7
	>>> product_info('Pen', price=5)
	Product: Pen
	Color: blue
	Price: 5
	>>>
	
### Створення значень опціональних парамтрів
	
***Зауважте:*** 
значення за замовчуванням обчислюються і створюються лише один раз, 
а саме при створенні функції! 
У цей момент вони зв'язуються з іменами відповідних параметрів. 

Тому будьте обережними якщо у якості значення за замовчуванням вказуєте мутабельні об'єкти. 

	:::python
	>>> def modify_list(lst=[]):
	...     lst.append(1)
	...     return lst
	...
	>>> l = modify_list()
	>>> l
	[1]
	>>> l = modify_list()
	>>> l
	[1, 1]
	>>>
	
Намагайтесь не використовувати мутабельні типи у якості значень за замовчуванням, 
якщо, звісно, ви чітко не усвідомлюєтє що саме робите. 
Вищенаведений код краще написати так:

	:::python
	>>> def modify_list(lst=None):
	...     if lst == None:
	...             lst = []
	...     lst.append(1)
	...     return lst
	...
	>>> l = modify_list()
	>>> l
	[1]
	>>> l = modify_list()
	>>> l
	[1]
	>>>
	
## Лише по ключу!

В Python 3 є можливість явно вказати, щоб частина аргументів завжди передавалась тільки як ключові. Напишемо функцію яка виводить певну кількість елементів послідовності починаючи з кінця:

	:::python
	>>> def tail(sequence, *, length=1):
	...     print(sequence[-length:])
	...
	>>>
	
Поміж параметрами функції ми поставили просто зірочку. Такий синтаксис означає, що усе що йде за зірочкою має передаватись тільки як ключові аргументи.

	:::python
	>>> tail('Hello, World', 5)
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	TypeError: tail() takes 1 positional argument but 2 were given
	>>>

Ми викликали функцію `tail()` передавши їй 2 позиційні аргументи, але інтерпретатор нам повідомляє, що ця функція може прийняти лише один позиційний аргумент. 
Давайте виправимо ситуацію передавши функції другий аргумент по ключу:

	:::python
	>>> tail('Hello, World', length=5)
	World
	>>>

