<!--
https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F#%D0%92%D1%8B%D0%B7%D0%BE%D0%B2_%D0%BF%D0%BE_%D1%81%D0%BE%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E_(call_by_sharing)
-->

# Стратегії обчислення

> **Стратегія обчислення** —  це семантика використання формальних і фактичних параметрів функції.

Кожна стратегія обчислення визначає, коли слід обчислювати аргументи функції і які знзчення передавати. Часто поняття стратегії обчислення називають "способом передачі параметрів", хоча для деяких стратегій обчислення (наприклад, «виклик по
необхідності») такий термін не є коректним.

Існує декілька стратегій обчислення, ось деякі:

* **Виклик по значенню** (call-by-value). Сама розповсюджена стратегія обчислення. При виклику по значенню, вираз-аргумент обчислюється, і отримане значенння зв'язується з відповідним формальним параметром функції (зазвичай
за допомогою копіювання цього значення у новую ділянку пам'яті). При цьому, якщо мова програмування 
дозволяє функціям присвоювати значення своїм параметрам, то зміни будуть стосуватися лише цих локальних копій, але видимі у місці виклика функції значення
залишаться незміненими після повернення.
* **Виклик по посиланню** При виклику по посиланню (call-by-reference), або передачі по посиланню (pass-by-
reference), функція неявно отримує посилання на змінну, яку було використано у якості аргумента, змість копії її значення. Зазвичай це означає, що функція може здійснювати модифікацію (тобто змінювати стан) змінної,
переданої в якості параметра, і це також матиме ефект у контексті, що викликав функцію.
* **Виклик по співвикористанню** (виклик зі спільним використанням ресурсів, call-by-sharing). Значення у
мові програмування основані на об'єктах, а не на примітивних типах. При виклику по співвикористанню функція
отримує значення, яке містить копію посилання на об'єкт. Сам об'єкт не копіюється — він буде використовуватись спільно. Як наслідок, присвоєння аргументу у тілі функції не має ефекта у контексті, що її викликав, але присвоєння компонентам цього аргумента — має.

У Python використовується стратегія обчислення "виклик по співвикористанню". На практиці це означає, що при передачі параметрів в функцію в Python ми не можемо прив'язати фактичні параметры до інших об'єктів або змінити їх, якщо вони
належать до немутабельним типів, однак можемо модифікувати їх значення, якщо вони належать до мутабельних типів.	


	:::python
	>>> def increase(number):
	...     print('Number was:', number)
	...     number = number + 1
	...     print('Number became:', number)
	...
	>>> x = 7
	>>> increase(x)
	Number was: 7
	Number became: 8
	>>> x
	7
	>>>

Значенн змінної `x` не змінилось оскільки вона вказує на немутабельний `int`.

	:::python
	>>> def add_to_list(lst):
	...     lst.append(777)
	...
	>>> my_list = [1, 2]
	>>> add_to_list(my_list)
	>>> my_list
	[1, 2, 777]
	>>>

Значенн змінної `my_list` змінилось оскільки вона вказує на мутабельний `list`.

Дуже часто можна зустріти ствердження, що у Python аргументи передається по посиланню. Однак, як ми впевнились вище, це не зовсім відповідає дійсності. Просто завжди пам'ятайте про це.


## Додаткові матеріали

["Стратегії обчислення" у Wikipedia](https://uk.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D1%96%D1%97_%D0%BE%D0%B1%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F)

## Завдання

Не запускаючи код на виконання визначте яке значення буде відповідати змінній `my_list` після його виконання і поясніть чому саме так. Можете перевірити себе запустивши код.

	:::python
	def modify_list(lst):
		lst = [777]
		
	my_list = [1, 2]
	modify_list(my_list)