# Магічні методи порівняння

В Python є багато магічних методів, створених для визначення інтуітивного порівняння між об'єктами використовуючи оператори. Крім того, вони надають спосіб перевизначити поведінку Python за замовчуванням для порівняння об'єктів (по посиланню). Ось список цих методів і що вони роблять:

- `__eq__(self, other)`  
Визначає поведінку оператора рівності, `==`.

- `__ne__(self, other)`  
Визначає поведінку оператора нерівності, `!=`.

- `__lt__(self, other)`  
Визначає поведінку оператора "меньше ніж", `<`

- `__gt__(self, other)`  
Визначає поведінку оператора "більше ніж", `>`

- `__le__(self, other)`  
Визначає поведінку оператора "меньше або дорівнює", `<=`

- `__ge__(self, other)`  
Визначає поведінку оператора "більше або дорівнює", `>=`

Реалізуємо клас, який описує слово. Ми можемо порівнювати слова лексиграфічно (по алфавіту), що є дефолтною поведнінкою при порівнянні символьних рядків, але можемо захотіти використовувати при порівнянні будь-який інший критерій, наприклад, довжина або ж кількість складні. Давайте порівнювати по довжині:

	:::python
	class Word(str):
		def __new__(cls, word):
			# Використовуємо __new__, оскільки тип str — немутабельний
			# і ми повинні ініціалізувати його раніше (при створенні)
			return str.__new__(cls, word)

		def __gt__(self, other):
			return len(self) > len(other)
		def __lt__(self, other):
			return len(self) < len(other)
		def __ge__(self, other):
			return len(self) >= len(other)
		def __le__(self, other):
			return len(self) <= len(other)

Перевірку на еквівалентність ми залишили від `str`.

Є можливість не визначати кожну з перевірок, а визначити тільки ті, на основі яких можна однозначно визначити інші, наприклад `__ge__`. А решту для нас може зробити декоратор `total_ordering` з вбудованого модуля `functools`. Достатньо перед визначенням класа вказати:

	@total_ordering
	class ...
