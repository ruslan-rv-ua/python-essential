### Синтаксичні помилки

Помилка синтаксису (`SyntaxError`) виникає коли синтаксичний аналізатор Python зіштовхується з ділянкою кода, котрий не відповідає специфікації мови програмування і який не може бути інтерпретовано.

Синтаксичні помилки у головному модулі програми виникають до початку виконання програми і не можуть бути перехоплені.

Ситуації, у яких синтаксична помилка у вигляді винятка `SyntaxError` може бути
перехоплена і оброблена:

- помилка синтаксиса у імпортованому модулі;
- помилка синтаксиса у коді, який представлений символьним рядком і передається функції `eval` або `exec`.

### Помилки часу виконання

Ось деякі класичні приклади виняткових ситуацій:

* ділення на нуль;
* помилка при спробі прочитати зовнішні дані;
* вичерпання доступної пам'яті.

### Винятки як класи

Винятки в Python — це насправді не що інше, як класи. Давайте переконаємось:

	:::python
	>>> 1/0
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	ZeroDivisionError: division by zero
	>>> ZeroDivisionError
	<class 'ZeroDivisionError'>
	>>> ZeroDivisionError.mro()
	[<class 'ZeroDivisionError'>, <class 'ArithmeticError'>, <class 'Exception'>, <class 'BaseException'>, <class 'object'>]
	>>>
	
Базовим класом для винятків є `BaseException`. Від нього успадковуються декілька спеціальних класів, які вказують на обов'язкове завершення програми, а також клас `Exception`. 

Від класа `Exception` успадковуються усі інші стандартні класи. Ось деякі дочірні для `Exception` класи:

* ArithmeticError — базовий клас для усіх винятків, пов'язаних з арифметичними операціями.
* BufferError — базовий клас для винятків, пов'язаних з операціями 
над буфером.
* LookupError — базовий клас для винятків, які виникають при зверненні по неіснуючому ключу чи індексу у послідовностях і відображеннях.

Повний перелік усіх винятків можна знайти у документації, рекомендується ознайомитись з ним.

Також при необхідності ми можемо створити власні винятки, у цьому разі нам треба успадковуватись саме від класа `Exception`, напряму чи опосередковано від інших класів.



### "Підйом" винятків

Python автоматично генерує винятки при виникненні помилки під час виконання. 
Але також є можливість сгенерувати виняток програмно. Робиться це за допомогою ключового слова `raise`. Після нього вказують об'єкт винятка. При конструюванні екземпляра винятк зазвичай вказують повідомлення, яке більш детально описує проблему, також деколи передають інші аргументи:

	:::python
	>>> raise ZeroDivisionError('Вчіть математику!')
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	ZeroDivisionError: Вчіть математику!
	>>>

Також можна вказати клас винятка, у цьому разі Python автоматично створить екземпляр класа викликавши відповідний конструктор без параметрів. 

	:::python
	>>> raise ZeroDivisionError
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	ZeroDivisionError
	>>>

Зауважте, що `raise` може викидати у якості винятків тільки екземпляри класа `BaseException` і його нащадків.




### Створення власних винятків

При розробці програмного забезпечення, особливо якщо ви створюєте програмний продукт, який можуть використовувати інші розробники, може виникнути потреба створити власні винятки, які будуть обробляти якісь специфічні помилки. Хорошою практикою є створити базовий клас успадкувавши його від `Exception` або іншого стандартного, а вже потім від цього базового класа успадкувати класи для конкретних помилок чи ситуацій. 

Приклад визначення власних винятків і їх використання:

	:::python
	class CoolFrameworkException(Exception):
		pass
		
	class VeryRareError(CoolFrameworkException):
		pass
		
	class SomeStrangeError(CoolFrameworkException):
		pass
		
	if __name__ == '__main__':
		raise SomeStrangeError('WTF?')




## Додаткові матеріали:

* [Документація: вбудовані винятки](https://docs.python.org/3.6/library/exceptions.html)
	
