Розглянемо основні операції з файлами. 

### Відкриття файла

Для створення файлових об'єктів нам не обов'язково інстанціювати об'єкти відповідних класів — Python надає нам більш зручний інтерфейс. 

Відкрити файл можна за допомогою функції `open()`. Ця функція знаходиться в модулі `io`, але доступна з глобального простору імен (автоматично імпортується в модуль `__builtins__`). 

	:::python
	open(
		file, 
		mode='r', 
		buffering=-1, 
		encoding=None, 
		errors=None,
		newline=None, 
		closefd=True,
		opener=None
	)
	
Функція повертає об'єкт файла.
	
Параметри функції `open()`:

- `file` – им'я файла або файловий дескриптор;
- `mode` – режим відкриття файла;
- `encoding` – кодування файла;
- `buffering` – керування буферізацією;
- `errors` — як обробляти помилки;
- `newline` — як обробляти символ нового рядка;
- `closefd` — вказує, чи потрібно закривати дескриптор файла;
- `opener` — об'єкт, який відкриває файл, має повертати дескриптор файла;

Розглянемо деякі з них детальніше. 

##### `file`

- Ім'я файла у вигляді символьного рядка включаючи абсолютний чи відносний шлях
- Дескриптор файла (ціле число) якщо ви вже відкрили потік низькорівневою функцією

Для корректного створення шляху до файла використовується функція `join` з вбудованого модуля `os.path`:

	:::python
	>>> from os.path import join`
	>>> join('..','windows','system32') # для Windows
	'..\\windows\\system32'
	>>>

##### `mode`

Режим відкриття файла. Символьний рядок який складається з одного, двох чи трьох символів. 

Перший символ:

|символ|значення|
|-|-|
|`r`|відкрити для читання (за замовчуванням)|
|`w`|відкрити для запису, вміст файла перед цим видаляється|
|`x`|відкрити для виняткового створення (піднімається `FileExistsError` якщо файл вже існує)|
|`a`|відкрити для запису, додаючи дані у кінець файла якщо він вже існує|

Другий або третій символ (необов'язкові, порядок не має значення):

|символ|значення|
|-|-|
|`b`|бінарний режим|
|`t`|текстовий режим (за замовчуванням)|
|`+`|відкрити для читання і запису|

##### `buffering`
	
Ціле число, вказує розмір буфера.

- якщо менше 0 — використовується стандартний блочний буфер
- якщо 0 — буферизація не використовується
- якщо більше 0 — вказує розмір буфера


	
	
	
### Закриття файла

Після закінчення роботи з файлом необхідно обов'язково його закрити, особливо якщо файл було відкрито для запису. Для закриття файла використовується метод файлового об'єкта `close()`. 

При використанні буферизованого доступу вміст буфера записується в файл при його заповненні або коли викликаються методи `flush()` або `close()`. Якщо не закрити файл, є ймовірність втратити дані що ще знаходяться у буфері і не записані на носій інформації. 
Крім того, якщо файл відкрито для запису, його буде заблоковано для відкриття для запису іншими процесами до того, поки файл не буде закрито. 
Усі відкриті файли автоматично закриваються при видаленні відповідних файлових об'єктів з пам'яті збиральником сміття інтерпретатора Python і при завершенні роботи самого інтерпретатора. Однак необхідно тримати файли відкритими мінімально необхідний час. 

Примусово "зкинути" буфер можна за допомогою метода `flush()`. 

### Робота за допомогою менеджера контекста

Усі файлові об'єкти є менеджерами контекста:

	:::python
	with open(filename, mode) as file:
		# perform actions on file
		
Таким чином файл буде гарантовано закрито як тільки буде виконано усі необхідні дії над ним. 


	
	
	
	
	
	
	
	
	
	
	
	
	
	