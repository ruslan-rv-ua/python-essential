# Успадкування

> ***Успадкування*** (наслідування, inheritance) — механізм утворення нових класів на основі використання властивостей і функціоналу вже існуючих класів.

Ключовими поняттями наслідування є підклас (subclass) і суперклас (super class). Суперклас ще називають базовим (base class) або батьківським (parent class), а підклас — похідним (derived class) або дочірнім (child class). 
Підклас успадковує властивості, методи та інші публічні атрибути з базового класа. Він також може перевизначати (override) методи базового класа. Якщо підклас не визначає свій конструктор, він успадковує конструктор базового класс за замовчуванням. 


### Успадкування в Python

В Python синтаксис для наслідування класів виглядає наступним чином:

	:::python
	class <subclass>(<superclass>):
		<subclass attributes>
		
Розглянемо на прикладі.

	:::python
	>>> class Base:
	...     def __init__(self):
	...             self.base_prop = 'base property'
	...     def method(self):
	...             print("Це метод з класа Base.")
	...             print("У об'єкта класа Base є атрибут base_prop, його значення:", self.base_prop)
	...
	>>> class Child(Base):
	...     def child_method(self):
	...             print("Це метод з класа Child.")
	...             print("Об'єкт класа Child має атрибут base_prop. Його створено в успадкованому конструкторі класа Base:", self.base_prop)
	...
	>>> c = Child()
	>>> c.method()
	Це метод з класа Base.
	У об'єкта класа Base є атрибут base_prop, його значення: base property
	>>> c.child_method()
	Це метод з класа Child.
	Об'єкт класа Child має атрибут base_prop. Його створено в успадкованому конструкторі класа Base: base property
	>>>
	
Що відбувається у цьому прикладі?

1. Клас Child успадковує від класа Base два методи: конструктор і метод `method()`.
1. Також клас Child має свій власний метод: `child_method()`.
1. При створенні об'єкта класа Child буде викликано успадкований конструктор класа Base. У конструкторі для об'єкта створюється атрибут base_prop. У об'єктів класа Child теж буде створено цей атрибут.


### Ієрархія успадкування

Клас може бути успадкованим від класа, який у свою чергу було успадковано від іншого класа. Коли розглядають увесь ланцюжок успадкованих і базових класів, говорять про **ієрархію успадкування**.

В Python є вбудований клас який має назву `object`. Від цього класа явно чи неявно успадковуються усі інші класи, як вбудовані, так і ті, що створююте ви. Якщо при створенні класа ви не вказуєте базовий клас, то неявним чином ваш клас буде успадковано від `object`. Отже наступні оголошення класа рівносильні:

	:::python
	class A:
		pass
		
	class A():
		pass
		
	class A(object):
		pass

Розглянемо наступну ієрархію класів:

	:::python
	>>> class A: pass
	...
	>>> class B(A): pass
	...
	>>> class C(B): pass
	...
	>>> c_obj = C()
	>>> c
	<__main__.Child object at 0x00000151150290F0>
	>>>

Дізнатись, чи є певний клас підкласом іншого класа по всій ієрархії успадкування, можна за допомогою вбудованої функції `issubclass()`:

	:::python
	>>> issubclass(C, B)
	True
	>>> issubclass(C, A)
	True
	>>> issubclass(C, object)
	True
	>>> issubclass(B, C)
	False
	>>>	

Також можна дізнатись чи є певний об'єкт екземпляром класа враховуючи всю ієрархію успадкування:

	:::python
	>>> isinstance(c_obj, C)
	True
	>>> isinstance(c_obj, B)
	True
	>>> isinstance(c_obj, object)
	True
	>>> isinstance('some striing', C)
	False
	>>> isinstance('some striing', object)
	True
	>>>
	
А тепер вкотре згадаємо що "в Python усе є об'єкт". І класи тут теж не виключення, тобто класи — це теж об'єкти. І як об'єкти вони мають свої атрибути.

У кожного класа є спеціальний атрибут, в якому міститься базовий клас, точніше кортеж який містить базові класи (чому саме так — трохи далі):

	:::python
	>>> C.__bases__
	(<class '__main__.B'>,)
	>>> B.__bases__
	(<class '__main__.A'>,)
	>>> A.__bases__
	(<class 'object'>,)
	>>>
	




	

	
	

### Успадкування і приватні атрибути

Як нам вже відомо, атрибути, які починаються з двох символів підкреслення (але не закінчуються ними) є приватними атрибутами класа. Поза видимістю класа до таких атрибутів застосовується механізм `name mangling` (спотворення імені), тобто такі атрибути "поза класом" будуть мати інші імена (клас+атрибут), у тому числі і в успадкованих класах. Це дозволяє "приховати" внутрішню реалізацію класа навіть для класів, які від нього успадкуються. Приклад:

	:::python
	>>> class Base:
	...     def __init__(self):
	...             self.__prop = 'property'
	...     def base_method(self):
	...             print("Це метод з класа Base.")
	...             print("У об'єкта класа Base є атрибут __prop, його значення:", self.__prop)
	...
	>>> class Child(Base):
	...     def child_method(self):
	...             print("Це метод з класа Child.")
	...             print("Спробуємо дістатись до атрибута з метода успадкованого класа:", self.__prop)
	...
	>>> c = Child()
	>>> c.base_method()
	Це метод з класа Base.
	У об'єкта класа Base є атрибут __prop, його значення: property
	>>> c.child_method()
	Це метод з класа Child.
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	  File "<stdin>", line 4, in child_method
	AttributeError: 'Child' object has no attribute '_Child__prop'
	>>>

	






### Лінеаризація

Як ми вже з'ясували, дочірній клас може не мати певного атрибута, але він може успадкувати його від базового класа. Для пошуку атрибутів в ієрархії класів використовується лінеаризація класів.

> ***Лінеаризація*** — це черговість, при якій проводиться пошук зазначеного атрибута в ієрархії класів.

Використовуючи лінеаризацію відбувається пошук атрибутів в ієрархії класів. При простому успадкуванні алгоритм пошуку атрибутів виглядає наступним чином:

- якщо атрибут, до якого відбувається доступ, не знайдено в поточному класі, то виконується його пошук в базовому класі;
* якщо атрибут не знайдено і в базовому класі, то виконується його пошук в базовому класі базового класа;
* пошук відбувається рекурсивно аж до класа `object`;
* якщо атрибут не знайдено і в класі `object`, то отримуємо вийняткову ситуацію

Приклад:

	:::python
	>>> class A:
	...     def f1(self):
	...             print('f1 method in class A')
	...
	>>>
	... class B(A):
	...     def f2(self):
	...             print('f2 method in class B')
	...
	>>>
	... class C(B):
	...     def f2(self):
	...             print('f2 method in class C')
	...     def f3(self):
	...             print('f3 method in class C')
	...
	>>> obj = C()
	>>> obj.f3()
	f3 method in class C
	>>> obj.f2()
	f2 method in class C
	>>> obj.f1()
	f1 method in class A
	>>> obj.f()
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	AttributeError: 'C' object has no attribute 'f'
	>>>


В Python лінеаризація ще називається MRO — Method Resolution Order, порядок вирішення методів. Назва може трошки вводити в оману, тому що таким чином відбувається пошук не тільки методів, а й будь-яких атрибутів.
	
Лінеаризація для певного класа знаходиться в його спеціальному атрибуті `__mro__`:
	
	:::python
	>>> C.__mro__
	>>> C.__mro__
	(<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
	>>>
	
Але частіше користуються атрибутом-методом класа, який повертає не кортеж, а одразу список:

	:::python
	>>> C.mro()
	[<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>]
	>>>

	
	
### Перевизначення і пошук методів

Уявімо ситуацію, що в базовому класі, від якого ми будемо успадковувати наш новий клас, вже реалізовано певний метод, котрий підходить нам по своїй функціональності, але у ньому не вистачає певних речей, або ж нам треба дещо змінити його функціонал. Звісно, що ми можемо повністю переписати цей метод у нашому новому класі, але з великою ймовірністю ми стикнемось з повторним використання коду. І якщо, припустимо, ми вносимо зміни в метод базового класа, то такіж з зміни нам доведеться вносити і в аналогічний метод нашого нового класа, що є небажаним (підвищується ймовірність припуститись помилки, зайва робота в решті решт).

Якщо в дочірньому класі певний атрибут було перевизначено, а потрібен доступ до відповідного атрибута базового класа, в Python це можна зробити двома способами. Один з них полягає у тому, що ми явно вказуємо базовий клас, відповідний атрибут і, при необхідності, передаємо екземпляр дочірнього класа (параметр `self`).

Розглянемо приклад.

	:::python
	>>> class Person:
	...     def __init__(self, name):
	...         self.name = name.title()
	...     def say_hello(self):
	...         print('Hi, I am', self.name)
	...
	>>> p = Person('john')
	>>> p.say_hello()
	Hi, I am John
	>>>
	
Зауважимо, що в конструкторі класа відбувається певна маніпуляція зі вхідними даними.

Окей, тепер нам треба створити клас, який описував би не просто людину, а співробітника певної організації. Співробітник має усі атрибути, які має і людина (зокрема ім'я), власне будь-який співробітник і є людиною, тому логічно успадкуватись від класа Person. Крім того співробітник має ще й заробітню плату. 

	:::python
	>>> class Employee(Person):
	...     def __init__(self, name, salary):
	...         Person.__init__(self, name)
	...         self.salary = salary
	...     def say_hello(self):
	...         Person.say_hello(self)
	...         print('My salary is', self.salary)
	...
	>>> e = Employee('JANE', 120)
	>>> e.say_hello()
	Hi, I am Jane
	My salary is 120
	>>>

В конструкторі дочірнього класа ми викликаємо конструктор базового класа при цьому передаючи йому екземпляр дочірнього класа і необхідні дані для ініціалізації артибутів. В конструкторі базового класа відбувається певна маніпуляція над вхідними даними і відбувається ініціалізація атрибута `name`. І вже потім в конструкторі дочірнього класа відбувається ініціалізація атрибута `salary`.

Аналогічно з метода `say_hello()` дочірнього класа викликається відповідний метод базового класа.

Недоліки такого підхода:

- ускладнюється підтримка кода якщо нам треба щось поміняти в ієрархії класів
- логіка кода чітко прив'язана до ієрархії успадкування класів і схильна до помилок, особливо при використанні множинного успадкування.
