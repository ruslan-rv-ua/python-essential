# Інкапсуляція

Класи в ООП бувають великими і складними. 
В них може бути багато полів і методів, які не повинні використовуватись за його межами. 
Вони просто для цього не призначені. 
Вони свого роду внутрішні шестерні, які забезпечують нормальну роботу великого механізму. 

Хорошою практикою вважається приховування усіх полів об'єктів, 
щоб запобігти прямого присвоєння значень з іншого місця програми. 
Їх значення можна змінювати і отримувати лише через виклики методів, спеціально для цього визначених. 
Наприклад, якщо необхідно перевіряти значення, яке присвоюється певному полю на коректність, 
то робити це кожного разу в основному коді програми буде неправильним. 
Перевірочний код має бути розміщено у методі, котрий отримує дані для присвоення полю. 
А саме поле має бути закритим для доступу ззовні класа. 
У цьому випадку йому неможливо буде присвоїти недопустиме значенння. 

> ***Інкапсуляція*** (encapsulation) — це механізм, який об'єднує дані і код, який маніпулює цими даними, а також захищає і те, і інше від зовнішнього втручання або неправильного використання.

Розглянемо приклад:

	:::python
	>>> class Person:
	...     def __init__(self, age):
	...             self.age = age
	...
	>>> p = Person(age=-35)
	>>> p.age
	-35
	>>> p.age = '35'
	>>> p.age
	'35'
	>>>
	
Поле `age` класа `Person` — це вік людини. 
У вищенаведеному прикладі ми двічі присвоїли некоректне значення цьому полю: 
при створенні об'єкта через конструктор та вказавши значення поля "напряму". 
Варто було б зробити дві речі: 

- в ініціалізаторі перевіряти значення на коректність
- заборонити зміну поля у об'єкта або ж перевіряти дані на коректність при зміні поля
