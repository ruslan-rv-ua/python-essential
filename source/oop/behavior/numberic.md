# Числові магічні методи

Ми можемо визначити поведінку об'єктів для числових операторів. Існує їх немало, і для кращої організації розіб'ємо їх на 5 категорій: унарні оператори, звичайні арифметичні оператори, відбиті арифметичні оператори, складні присвоєння і перетворення типів. Розглянемо деякі з них:

#### Унарні оператори і функції

- `__pos__(self)`  
Визначає поведінку для унарного плюса `(+some_object)`

- `__neg__(self)`  
Визначає поведінку для унарного мінуса `(-some_object)`

- `__abs__(self)`  
Визначає поведінку для вбудованої функції `abs()`

- `__round__(self)`  
Визначає поведінку для вбудованої функції `round()`. `n` — це кількість знаків, до якого округлити

- `__floor__(self)`  
Визначає поведінку для `math.floor()`

- `__ceil__(self)`  
Визначає поведінку для `math.ceil()`

- `__trunc__(self)`  
Визначає поведінку для `math.trunc()`



#### Звичайні арифметичні оператори

- `__add__(self, other)`  
Додавання

- `__sub__(self, other)`  
Віднімання

- `__mul__(self, other)`
Множення

- `__floordiv__(self, other)`  
Цілочислене ділення, оператор `//`

- `__truediv__(self, other)`
Ділення, оператор `/`

- `__mod__(self, other)`  
Залишок від ділення, оператор `%`

- `__divmod__(self, other)`  
Визначає поведінку для вбудованої функції `divmod()`

- `__pow__(self, other)`  
Підведення у ступінь, оператор `**`



#### Відбиті арифметичні оператори

Відбиті оператори — це не якась нова концепція. Якщо звичайна операція додавання ми записуємо як:

	some_object + other
	
то відбите додавання виглядає так:

	other + some_object
	
Таким чином усі ці магичні методи роблять те ж саме, що і їх звичайні версії, але для аргументів, які знаходяться праворуч, і тільки у випадку, якщо для лівого операнда не визначено відповідного метода. Наприклад, операція `x + y` буде спочатку намагатись викликати `x.__add__(y)`, і тільки у тому випадку, якщо це не 	вийшло, буде намагатись викликати y.__radd__(x). Аналогічно для решти методів.

- `__radd__(self, other)`
- `__rsub__(self, other)`
- `__rmul__(self, other)`
- `__rfloordiv__(self, other)`
- `__rtruediv__(self, other)`
- `__rmod__(self, other)`
- `__rdivmod__(self, other)`
- `__rpow__`

#### Складні присвоєння

Складні присвоєння — це комбінація "звичайного" оператора і присвоєння. 

	:::python
	x = 5
	x += 1 # тобто x = x + 1
	
Кожен з цих методів повинен повертати значеня, котре буде присвоєно змінній зліва. Наприклад, для `a += b`, __iadd__ має повернути `a + b`, що буде присвоєно `a`.

- `__iadd__(self, other)`
- `__isub__(self, other)`

і так далі.






#### Магичні методи перетворення типів

В Python є багато магичних методів для визначення поведнінки для вбудованих функцій перетворення типів:

- `__int__(self)`  
Перетворення в `int`

- `__float__(self)`

та інші.




	
	
	
	
	
	
	
	
	
	
	
	
	
	



## Додаткові матеріали

[Документація Python: спеціальні методи](https://docs.python.org/3/reference/datamodel.html#specialnames)

<!---
https://ru.stackoverflow.com/questions/646280/%d0%9c%d0%b0%d0%b3%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8%d0%b5-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d1%8b/647069#647069

https://www.severcart.org/blog/all/python_getattr/



 --->