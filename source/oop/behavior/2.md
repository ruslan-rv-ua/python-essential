# "Магічні" методи. Перевизначення операторів

Спеціальний, або магічний метод — це метод, який викликається неявно, часто щоб виконати операцію для певного типа. Наприклад, можна визначити __bool__ метод, щоб вказати чи є об'єкт True/False в булевому контексті. Таким чином дуже багато аспектів поведінки об'єктів в Python можна змінити.

Імена магічних методів починаються і закінчуються двома символами підкреслення, наприклад:

	__init__
	__getattr__
	__eq__



### Конструювання та ініціалізація

Нам вже відомий самий базовий магічний метод, `__init__`. За його допомоги ми можемо ініціалізвати об'єкт. Однак, коли ми напишемо:

	x = SomeClass()
	
'__init__' це не саме перше, що викликається. Насправді екземпляр об'єкта створює метод `__new__`, а вже потім ініціалізатор. На іншому кінці життєвого цикла об'єкта знаходиться метод `__del__`. Давайте детальніше розглянемо ці три магічних метода.

#### `__new__(cls, [...])`

Конструктор класа. Це перший метод, який буде викликано при створенні об'єкта. Він приймає в якості параметрів клас і потім будь-які інші аргументи, які буде передано в `__init__`. `__new__` використовується дуже рідко, але деколи буває корисним, зокрема, коли клас успадковується від немутабельного (immutable) типа, такого як кортеж (tuple) чи рядок.

#### `__init__(self, [...)`

Ініціалізатор класа. Йому передається усе, з чим було викликано конструктор. Наприклад, якщо ми напишемо

	x = SomeClass(10, 'foo')

`__init__` отримає 10 і 'foo' в якості аргументів. 
`__init__` майже повсемістно використовується при визначенні класів. 
Майже завжди цей метод помилково називають конструктором.

#### `__del__(self)`

Якщо `__new__` і `__init__` — конструктори об'єкта, `__del__` — його деструктор. Він не визначає поведінку для оператора `del`, 
тому цей код не є еквівалентним `x.__del__(). 
Він визначає поведінку об'єкта у той час, коли за об'єкт береться збиральник сміття. 
Це може бути доволі зручно для об'єктів, які можуть потребувати додаткових "чисток" під час видалення, наприклад сокети чи файлові об'єкти. 
Однак пам'ятайте, що
`__del__` не може слугувати заміною для хороших програмістських практик. 
Завжди завершуйте з'єднання, якщо закінчили з нми працювати і так далі! Фактично, через відсутність гарантії виклику, `__del__` не повинен використовуватись майже ніколи. Використовуйте його з обережністю!










	
### Представлення своїх класів

Часто буває корисним представлення класа у вигляді символьного рядка. В Python існує декілька методів, які ви можете визначити для налаштування поведінки вбудованих функцій при представленні вашого класа.

#### `__str__(self)`

Визначає поведінку функції `str()`, яка була викликана для екземпляра вашого класа.

#### `__repr__(self)`

Визначає поведінку функції 'repr()', викликаної для екземпляра вашого класа. Головна відмінність від `str()` — в цільовій аудиторії. `repr()` більше призначено для машино-орієнтованого вивода, більш того, це по можливості має бути валідний код на Python) для створення екземпляра класа. `str()` признзачено для читання людьми.

	:::python
	>>> class Person():
	...     def __init__(self, name, email):
	...             self.name = name
	...             self.email = email
	...     def __str__(self):
	...             return '{name} <{email}>'.format(name=self.name, email=self.email)
	...     def __repr__(self):
	...             return 'Person("{name}", "<{email}>")'.format(name=self.name, email=self.email)
	...
	>>> p = Person('John Doe', 'johnny@nowhere.com')
	>>> str(p)
	'John Doe <johnny@nowhere.com>'
	>>> print(p)
	John Doe <johnny@nowhere.com>
	>>> repr(p)
	'Person("John Doe", "<johnny@nowhere.com>")'
	>>> p
	Person("John Doe", "<johnny@nowhere.com>")
	>>>
	
	
	
### Магічні методи порівняння

В Python є багато магічних методів, створених для визначення інтуітивного порівняння між об'єктами використовуючи оператори. Крім того, вони надають спосіб перевизначити поведінку Pytho за замовчуванням для порівняння об'єктів (по посиланню). Ось список цих методів і що вони роблять:

- `__eq__(self, other)`  
Визначає поведінку оператора рівності, `==`.

- `__ne__(self, other)`  
Визначає поведінку оператора нерівності, `!=`.

- `__lt__(self, other)`  
Визначає поведінку оператора "меньше ніж", `<`

- `__gt__(self, other)`  
Визначає поведінку оператора "більше ніж", `>`

- `__le__(self, other)`  
Визначає поведінку оператора "меньше або дорівнює", `<=`

- `__ge__(self, other)`  
Визначає поведінку оператора "більше або дорівнює", `>=`

Реалізуємо клас, який описує слово. Ми можемо порівнювати слова лексиграфічно (по алфавіту), що є дефолтною поведнінкою при порівнянні символьних рядків, але можемо захотіти використовувати при порівнянні будь-який інший критерій, наприклад, довжина або ж кількість складні. Давайте порівнювати по довжині:

	:::python
	class Word(str):
		def __new__(cls, word):
			# Використовуємо __new__, оскільки тип str — немутабельний
			# і ми повинні ініціалізувати його раніше (при створенні)
			return str.__new__(cls, word)

		def __gt__(self, other):
			return len(self) > len(other)
		def __lt__(self, other):
			return len(self) < len(other)
		def __ge__(self, other):
			return len(self) >= len(other)
		def __le__(self, other):
			return len(self) <= len(other)

Перевірку на еквівалентність ми залишили від `str`.

Є можливість не визначати кожну з перевірок, а визначити тільки ті, на основі яких можна однозначно визначити інші, наприклад `__ge__`. А решту для нас може зробити декоратор `total_ordering` з вбудованого модуля `functools`. Достатньо перед визначенням класа вказати:

	@total_ordering
	class ...
	
	
### Числові магічні методи

Ми можемо визначити поведінку об'єктів для числових операторів. Існує їх немало, і для кращої організації розіб'ємо їх на 5 категорій: унарні оператори, звичайні арифметичні оператори, відбиті арифметичні оператори, складні присвоєння і перетворення типів. Розглянемо деякі з них:

#### Унарні оператори і функції

- `__pos__(self)`  
Визначає поведінку для унарного плюса `(+some_object)`

- `__neg__(self)`  
Визначає поведінку для унарного мінуса `(-some_object)`

- `__abs__(self)`  
Визначає поведінку для вбудованої функції `abs()`

- `__round__(self)`  
Визначає поведінку для вбудованої функції `round()`. `n` — це кількість знаків, до якого округлити

- `__floor__(self)`  
Визначає поведінку для `math.floor()`

- `__ceil__(self)`  
Визначає поведінку для `math.ceil()`

- `__trunc__(self)`  
Визначає поведінку для `math.trunc()`



#### Звичайні арифметичні оператори

- `__add__(self, other)`  
Додавання

- `__sub__(self, other)`  
Віднімання

- `__mul__(self, other)`
Множення

- `__floordiv__(self, other)`  
Цілочислене ділення, оператор `//`

- `__truediv__(self, other)`
Ділення, оператор `/`

- `__mod__(self, other)`  
Залишок від ділення, оператор `%`

- `__divmod__(self, other)`  
Визначає поведінку для вбудованої функції `divmod()`

- `__pow__(self, other)`  
Підведення у ступінь, оператор `**`



#### Відбиті арифметичні оператори

Відбиті оператори — це не якась нова концепція. Якщо звичайна операція додавання ми записуємо як:

	some_object + other
	
то відбите додавання виглядає так:

	other + some_object
	
Таким чином усі ці магичні методи роблять те ж саме, що і їх звичайні версії, але для аргументів, які знаходяться праворуч, і тільки у випадку, якщо для лівого операнда не визначено відповідного метода. Наприклад, операція `x + y` буде спочатку намагатись викликати `x.__add__(y)`, і тільки у тому випадку, якщо це не 	вийшло, буде намагатись викликати y.__radd__(x). Аналогічно для решти методів.

- `__radd__(self, other)`
- `__rsub__(self, other)`
- `__rmul__(self, other)`
- `__rfloordiv__(self, other)`
- `__rtruediv__(self, other)`
- `__rmod__(self, other)`
- `__rdivmod__(self, other)`
- `__rpow__`

#### Складні присвоєння

Складні присвоєння — це комбінація "звичайного" оператора і присвоєння. 

	:::python
	x = 5
	x += 1 # тобто x = x + 1
	
Кожен з цих методів повинен повертати значеня, котре буде присвоєно змінній зліва. Наприклад, для `a += b`, __iadd__ має повернути `a + b`, що буде присвоєно `a`.

- `__iadd__(self, other)`
- `__isub__(self, other)`

і так далі.






#### Магичні методи перетворення типів

В Python є багато магичних методів для визначення поведнінки для вбудованих функцій перетворення типів:

- `__int__(self)`  
Перетворення в `int`

- `__float__(self)`

та інші.




	
	
	
	
	
	
	
	
	
	
	
	
	
	



## Додаткові матеріали

[Документація Python: спеціальні методи](https://docs.python.org/3/reference/datamodel.html#specialnames)

<!---
https://ru.stackoverflow.com/questions/646280/%d0%9c%d0%b0%d0%b3%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b8%d0%b5-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d1%8b/647069#647069

https://www.severcart.org/blog/all/python_getattr/



 --->