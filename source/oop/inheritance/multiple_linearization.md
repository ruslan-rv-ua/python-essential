# Лінеарізація і множинна спадковість

При множинній спадковості виникає питання: а як саме треба виконувати лінеарізацію класів? Атже варіантів обійти всю ієрархію класів коли у одного класа є більше ніж один базовий клас можна побудувати декілька. При цьому не повинна "ламатись" логічна структура успадкування, це напряму впливає на алгоритм пошуку атрибутів в ієрархії класів.

Самий простий приклад де виникає неоднозначність пошуку методів — задача ромбовидного успадкування. Вивчіть самостійно наступний код і зробіть припущення, що буде виведено в результаті його виконання:

	:::python
	class Animal:
		def hello(self):
			print('Hello, I am Animal')
			
	class Eagle(Animal):
		def hello(self):
			print('Hello, I am Eagle')
		
	class Horse(Animal):
		pass
		
	class Pegasus(Eagle, Horse):
		pass
		
	p = Pegasus()
	p.hello()

Підходів побудови лінеаризації при множинній спадковості існує декілька, в різних мовах програмування можуть використовуватись різні підходи. А в декотрих мовах програмування, які підтримують парадигму ООП, множинне успадкування відсутнє.

В Python використовується алгоритм C3-лінеаризації, котрий дозволяє побудувати стійкий список з самого класа і усіх його предків (батьків і прабатьків). Цей алгоритм вирішує більшість проблем при лінеаризації множинного успадкування. Алгоритм відносно складний, зовсім спрощено його можна представити так:

* у список додається клас об'єкта (далі — дочірній клас)
* у список додаються базові класи дочірнього класа у тому порядку, як вони вказані при декларації дочірнього класа
* у список додаються базові класи базових класів і так далі рекурсивно аж до класа `object`
* якщо якийсь клас опиняється у списку двічі — залишається тільки останнє його входження

Як результат, ми рухаємось по рівням, не звертаємось до базового класа до того, як звернемось до усіх його нащадків, навіть якщо нащадків у цього базового класа декілька.

Алгоритм забезпечує пошук перевизначеного метода базового класа, якщо цей метод перевизначено хоча б у одному нащадку цього базового класа.

	:::python
	>>> class Animal:
	...     pass
	...
	>>>
	>>> class Eagle(Animal):
	...     pass
	...
	>>>
	>>> class Horse(Animal):
	...     pass
	...
	>>>
	>>> class Pegasus(Eagle, Horse):
	...     pass
	...
	>>> for c in Pegasus.mro():
	...     print(c.__name__)
	...
	Pegasus
	Eagle
	Horse
	Animal
	object
	>>>

Як видно з прикладу, лінеарізація обходить усі класи нашої ієрархії. 

Класи `Eagle` і `Horse` йдуть у тій послідовності, як перераховані при визначенні класа `Pegasus`. Давайте поміняємо їх місцями і подивимось як це вплине на лінеарізацію:

	:::python
	>>> class Pegasus(Horse, Eagle):
	...     pass
	...
	>>> for c in Pegasus.mro():
	...     print(c.__name__)
	...
	Pegasus
	Horse
	Eagle
	Animal
	object
	>>>

	

	

