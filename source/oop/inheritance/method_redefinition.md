# Перевизначення і пошук методів

Уявімо ситуацію, що в базовому класі, від якого ми будемо успадковувати наш новий клас, вже реалізовано певний метод, котрий підходить нам по своїй функціональності, але у ньому не вистачає певних речей, або ж нам треба дещо змінити його функціонал. Звісно, що ми можемо повністю переписати цей метод у нашому новому класі, але з великою ймовірністю ми стикнемось з повторним використання коду. І якщо, припустимо, ми вносимо зміни в метод базового класа, то такіж з зміни нам доведеться вносити і в аналогічний метод нашого нового класа, що є небажаним (підвищується ймовірність припуститись помилки, зайва робота в решті решт).

Якщо в дочірньому класі певний атрибут було перевизначено, а потрібен доступ до відповідного атрибута базового класа, в Python це можна зробити двома способами. Один з них полягає у тому, що ми явно вказуємо базовий клас, відповідний атрибут і, при необхідності, передаємо екземпляр дочірнього класа (параметр `self`).

Розглянемо приклад.

	:::python
	>>> class Person:
	...     def __init__(self, name):
	...         self.name = name.title()
	...     def say_hello(self):
	...         print('Hi, I am', self.name)
	...
	>>> p = Person('john')
	>>> p.say_hello()
	Hi, I am John
	>>>
	
Зауважимо, що в конструкторі класа відбувається певна маніпуляція зі вхідними даними.

Окей, тепер нам треба створити клас, який описував би не просто людину, а співробітника певної організації. Співробітник має усі атрибути, які має і людина (зокрема ім'я), власне будь-який співробітник і є людиною, тому логічно успадкуватись від класа Person. Крім того співробітник має ще й заробітню плату. 

	:::python
	>>> class Employee(Person):
	...     def __init__(self, name, salary):
	...         Person.__init__(self, name)
	...         self.salary = salary
	...     def say_hello(self):
	...         Person.say_hello(self)
	...         print('My salary is', self.salary)
	...
	>>> e = Employee('JANE', 120)
	>>> e.say_hello()
	Hi, I am Jane
	My salary is 120
	>>>

В конструкторі дочірнього класа ми викликаємо конструктор базового класа при цьому передаючи йому екземпляр дочірнього класа і необхідні дані для ініціалізації артибутів. В конструкторі базового класа відбувається певна маніпуляція над вхідними даними і відбувається ініціалізація атрибута `name`. І вже потім в конструкторі дочірнього класа відбувається ініціалізація атрибута `salary`.

Аналогічно з метода `say_hello()` дочірнього класа викликається відповідний метод базового класа.

Недоліки такого підхода:

- ускладнюється підтримка кода якщо нам треба щось поміняти в ієрархії класів
- логіка кода чітко прив'язана до ієрархії успадкування класів і схильна до помилок, особливо при використанні множинного успадкування.
