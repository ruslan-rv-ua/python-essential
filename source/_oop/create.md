# ООП в Python

Насамперед зауважимо, що в Python існує дві реалізації класів: так звані "класи старого типу" і "класи нового типу". Цей "розподіл" починається з Python версії 2.2. В класи нового типу було внесено відносно суттєві зміни задля покращення реалізації ООП. В Python починаючи з версії 3.0 підтримуються лише класи нового типу, класи старого типу не підтримуються як застарілі. В даному кусрі ми розглядаємо лише класи нового типу.

### Створення класів і об'єктів

В мові програмування Python класи створюють за допомогою команди class, після якої вказують им'я класа, потім ставиться двокрапка, далі з нового рядка і з відступом реалізується тіло класа:

	class NameOfClass:
		pass
		
Якщо клас є дочірнім, то батьківські класи перераховуються у круглих дужках після імені класа:

	class MyClass(ParentClass):
		pass
		
Об'єкт створюється шляхом виклику класа за його именем. При цьому після імені класа обов'язково ставляться дужки. Оскільки у програмному коді важливо не згубити посилання на щойно створений об'єкт, то зазвичай його пов'язують зі змінною. Отже створення об'єкта найчастіше виглядає так:

	class MyClass(ParentClass):
		pass

	obj = MyClass()
	obj2 = MyClass()
	




### Клас як модуль

В Python клас можна представити подібно модулю. Так само як у модулі у ньому можуть бути свої змінні зі значеннями і функції. Так само як у модулі у класа є власний простір імен, доступ до якого можливий через ім'я клас:

	>>> class Adder:
	...     n = 5
	...     def add(v):
	...             return v + Adder.n
	...
	>>> Adder.n
	5
	>>> Adder.add(4)
	9
	>>>

Однак у випадку класів використовується дещо інша термінологія. Імена, визначені в класі, називаються атрибутами цього класа. В вищенаведеному прикладі імена n і add — це атрибути клас Adder. Атрибутb-змінні часто називають полями і деколи властивостями. Атрибути-функції називаються методами. Кількість полів і методів у класі може бути довільною.




### Клас як створювач об'єктів

	>>> a = Adder()
	>>> a.n
	5
	>>> a.add(4)
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	TypeError: add() takes 1 positional argument but 2 were given
	>>>
	
Інтерпретатор повідомляє нам, що `add()` приймає тільки один аргумент, а було передано два. Звідки ж взявся другий аргумент, і хто він такий, якщо у дужках було вказано тільки одне число 4?

Клас створює об'єкти, які у певному сенсі є його спадкоємцями. Це означає, що якщо у об'єкта немає власного поля n, то інтерпретатор шукає його на один рівень вище, тобто у класі. Таким чином, якщо ми присвоюємо об'єкту поле с таким самим ім'ям як у класі, то воно перекриває, або перевизначає, поле клас:

	>>> a.n = 10
	>>> a.n
	10
	>>> Adder.n
	5
	>>>
	
Тут змінні `a.n` і `Adder.n` — це різні змінні. Перша знаходиться у просторі імен об'єкта, друга — у просторі класа `Adder`. Якщо б ми не додали поле `n` до об'єкта `a`, то інтерпретатор піднявся б вище по дереву наслідування і прийшов би у кла, де би і знайшов це поле.

Щодо методів, то вони також наслідуються об'єктами клас. У даному випадку у об'єкта `a` немає свого власного метода `add`, отже, він шукається в клас `Adder`. Однак від клас `Adder` може бути породжено багато об'єктів. Методи ж найчастіше призначаються для обробки об'єктів. Таким чином, коли викликається метод, у нього треба передати конкретний об'єкт, який він буде обробляти.

Зрозуміло, що екземпляр, що передається — це об'єкт, до якого застосовується метод. Вираз `a.add()` виконується інтерпретатором наступним чином:

1. Шукаю атрибут `add()` у об'єкта `a`. Не знайшов.
1. Тоді йду шукати у клас `Adder`, так як він створив об'єкт `a`.
1. Тут знайшов метод. Передаю йому об'єкт, до якого цей метод треба застосувати, і аргумент, що вказано у дужках.

Іншими словами, вираз

	a.add(4)

перетвоюється у вираз
	
	Adder.add(a, 4)
	
Таким чином, інтерпретатор спробував передати у метод add() класа Adder два фргумента — об'єкт a і число 4. Але ми запрограмували метод add() так, щоо він приймає тільки один параметр. В Python визначення методів не передбачають прийняття об'єкта як зрозуміле за замовчуванням. Об'єкт що приймається треба вказувати явно.

За згодою у Python для посилання на об'єкт використовується ім'я `self`. Ось так повинен виглядати метод add(), якщо ми плануємо викликати його через об'єкти:

	>>> class Adder:
	...     n = 5
	...     def add(self, v):
	...             return v + self.n
	...
	>>>
	
Змінна self зв'язується з об'ктом, до якого було застосовано даний метод, і через цю змінну ми отримуємо доступ до атрибутів об'єкта. Коли цей же метод застосовується до іншого об'єкта, то self зв'яжеться вже з саме цим іншим об'єктом, і через цю змінну будуть вилучатись тільки його поля.

Давайте протестємо оновлений метод:

	>>> class Adder:
	...     n = 5
	...     def add(self, v):
	...             return v + self.n
	...
	>>> a = Adder()
	>>> b = Adder()
	>>> a.n = 10
	>>> a.add(3)
	13
	>>> b.add(4)
	9
	>>>

Тут від класа Adder створюється два об'єкта – a та b. Для об'єкта a заводиться власне поле n. Об'єкт b, не має такого поля, отже успадковує n від клас Adder. Переконаємось у цьому:

	>>> a.n is Adder.n
	False
	>>> b.n is Adder.n
	True
	>>>
	
У методі add() вираз self.n – це звернення до поля n, переданого об'єкта, і не важливо, на якому рівні наслідування його буде знайдено.




### Зміна полів об'єкта

В Python об'єкту можна не тільки перевизначати поля і методи, успадковані від класа, але можна додавати нові, яких немає у класі:

	>>> a.test = 'Hi'
	>>> a.test
	'Hi'
	>>> Adder.test
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	AttributeError: type object 'Adder' has no attribute 'test'
	>>>
	
Однак у програмуванні так не прийнято, тому що тоді об'єкти одного класа будуть відрізнятись між собою по набору атрибутів. Це затруднить автоматизацію їх обробки, внесе у програму хаос.


	
	
	
	
	
	

