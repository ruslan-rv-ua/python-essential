# Множинне успадкування

> ***Множинна спадко́вість*** — властивість деяких обʼєктно-орієнтованих мов програмування, в яких класи можуть успадкувати поведінку і властивості більш ніж від одного суперкласу (безпосереднього батьківського класу). Це відрізняється від простого спадкування, у випадку якого клас може мати тільки один суперклас. 

Python підтримує множинну спадковість:

	:::python
	>>> class Horse:
	...     def run(self):
	...             print("Я біжу!")
	...
	>>>
	... class Eagle:
	...     def fly(self):
	...             print("Я лечу!")
	...
	>>>
	... class Pegasus(Horse, Eagle):
	...     pass
	...
	>>>
	... p = Pegasus()
	>>> p.run()
	Я біжу!
	>>> p.fly()
	Я лечу!
	>>>
	
У вищенаведеному прикладі клас `Pegasus` успадкував від класа `Horse` метод `run()`, а від класа `Eagle` — метод `fly()`.

Зауважимо, що у множинної спадковості є як переваги, так і недоліки. 
До переваг можна віднести те, що множинна спадковість дозволяє проектувати доволі складні і гнучкі ієрархії класів. 
Але разом з тим використання цього механізму може призвести до появи у коді доволі серйозних помилок. Сама наявність множинної спадковості може бути індикатором наявності помилок в проектуванні архітектури вашого застосунку, тому що множинна спадковість на практиці використовується вкрай рідко. І якщо у вас виникає думка використати множинну спадковість, то треба добре подумати, чи правильно ви розбиваєте предметну область на класи взагалі. І тільки якщо ви дійдете до висновку, що використання множинної спадковості доречне і дійсно може спростити код, тоді вже можете використовувати її.
	

	
	
### Лінеарізація і множинна спадковість

При множинній спадковості виникає питання: а як саме треба виконувати лінеарізацію класів? Атже варіантів обійти всю ієрархію класів коли у одного класа є більше ніж один базовий клас можна побудувати декілька. При цьому не повинна "ламатись" логічна структура успадкування, це напряму впливає на алгоритм пошуку атрибутів в ієрархії класів.

Самий простий приклад де виникає неоднозначність пошуку методів — задача ромбовидного успадкування. Вивчіть самостійно наступний код і зробіть припущення, що буде виведено в результаті його виконання:

	:::python
	class Animal:
		def hello(self):
			print('Hello, I am Animal')
			
	class Eagle(Animal):
		def hello(self):
			print('Hello, I am Eagle')
		
	class Horse(Animal):
		pass
		
	class Pegasus(Eagle, Horse):
		pass
		
	p = Pegasus()
	p.hello()

Підходів побудови лінеаризації при множинній спадковості існує декілька, в різних мовах програмування можуть використовуватись різні підходи. А в декотрих мовах програмування, які підтримують парадигму ООП, множинне успадкування відсутнє.

В Python використовується алгоритм C3-лінеаризації, котрий дозволяє побудувати стійкий список з самого класа і усіх його предків (батьків і прабатьків). Цей алгоритм вирішує більшість проблем при лінеаризації множинного успадкування. Алгоритм відносно складний, зовсім спрощено його можна представити так:

* у список додається клас об'єкта (далі — дочірній клас)
* у список додаються базові класи дочірнього класа у тому порядку, як вони вказані при декларації дочірнього класа
* у список додаються базові класи базових класів і так далі рекурсивно аж до класа `object`
* якщо якийсь клас опиняється у списку двічі — залишається тільки останнє його входження

Як результат, ми рухаємось по рівням, не звертаємось до базового класа до того, як звернемось до усіх його нащадків, навіть якщо нащадків у цього базового класа декілька.

Алгоритм забезпечує пошук перевизначеного метода базового класа, якщо цей метод перевизначено хоча б у одному нащадку цього базового класа.

	:::python
	>>> class Animal:
	...     pass
	...
	>>>
	>>> class Eagle(Animal):
	...     pass
	...
	>>>
	>>> class Horse(Animal):
	...     pass
	...
	>>>
	>>> class Pegasus(Eagle, Horse):
	...     pass
	...
	>>> for c in Pegasus.mro():
	...     print(c.__name__)
	...
	Pegasus
	Eagle
	Horse
	Animal
	object
	>>>

Як видно з прикладу, лінеарізація обходить усі класи нашої ієрархії. 

Класи `Eagle` і `Horse` йдуть у тій послідовності, як перераховані при визначенні класа `Pegasus`. Давайте поміняємо їх місцями і подивимось як це вплине на лінеарізацію:

	:::python
	>>> class Pegasus(Horse, Eagle):
	...     pass
	...
	>>> for c in Pegasus.mro():
	...     print(c.__name__)
	...
	Pegasus
	Horse
	Eagle
	Animal
	object
	>>>

	

	

### Пошук методів і лінеарізація

Як згадувалось раніше, доступ до атрибутів базового класа можна отримати шляхом прямого вказання назви класа і, власне, атрибута. Існує ще один спосіб, який позбавлений недоліків попереднього.

Існує спеціальний клас `super`, екземпляри якого є спеціальними проксі-об'єктами (об'єктами-посередниками), які прив'язані до даної ієрархії класів і які надають доступ до атрибутів наступного класа в лінеаризації 
того класа, в якому було створено об'єкт `super`.

Таким чином, за допомогою `super` можна отримати доступ до атрибутів суперкласа, не вказуючи його імені, причому це буде давати коректні результати навіть при використанні множинного успадкування.

Приклад:

	:::python
	super(MyClass, self).method()
	
Якщо при створенні екземпляра класа `super` не вказувати параметри, то автоматично будуть отримані поточні клас і його екземпляр:

	:::python
	super().method()
	
Приклад використання `super()` при простому успадкуванні:

	:::python
	>>> class Person:
	...     def __init__(self, name):
	...             self.name = name.title()
	...     def say_hello(self):
	...             print('Hi, I am', self.name)
	...
	>>>
	... class Employee(Person):
	...     def __init__(self, name, salary):
	...             super().__init__(name)
	...             self.salary = salary
	...     def say_hello(self):
	...             super().say_hello()
	...             print('My salary is', self.salary)
	...
	>>>
	>>> e = Employee('janE', 120)
	>>> e.say_hello()
	Hi, I am Jane
	My salary is 120
	>>>

З класа `Employee` ми отримуємо доступ до атрибутів класа `Person` за допомогою `super()`. Зауважте: нам тепер не треба вказувати навіть поточний екземпляр класа.

Тепер звернемось до множинної спадковості:

	:::python
	>>> class Animal:
	...     def __init__(self):
	...             self.can_run = False
	...             self.can_fly = False
	...
	>>>
	>>> class Horse(Animal):
	...     def __init__(self):
	...             super().__init__()
	...             self.can_run = True
	...
	>>>
	>>> class Eagle(Animal):
	...     def __init__(self):
	...             super().__init__()
	...             self.can_fly = True
	...
	>>>
	>>> class Pegasus(Horse, Eagle):
	...     pass
	...
	>>> p = Pegasus()
	>>> p.can_run
	True
	>>> p.can_fly
	True
	>>>
	
Щоб краще зрозуміти, як це працює, давайте спочатку вивчимо лінеаризацію класа `Pegasus`:
	
	:::python
	>>> Pegasus.mro()
	[<class '__main__.Pegasus'>, <class '__main__.Horse'>, <class '__main__.Eagle'>, <class '__main__.Animal'>, <class 'object'>]
	>>>
	
Тепер покроково:

1. В класі `Pegasus` конструктора не оголошено, отже згідно лінеаризації викликаємо конструктор класа `Horse`
1. В конструкторі `Horse` за допомогою `super()` викликається конструктор "попереднього" класа, згідно MRO це буде конструктор класа `Eagle`
1. В конструкторі `Eagle` за допомогою `super()` викликається конструктор "попереднього" класа, згідно MRO це буде конструктор класа `Animal`
	
	
	
	
	
	
	

## Додаткові матеріали

[C3-линеаризация](https://ru.wikipedia.org/wiki/C3-%D0%BB%D0%B8%D0%BD%D0%B5%D0%B0%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)

<!---
https://otus.ru/nest/post/165/
--->